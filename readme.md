# DP.Repository

C# implementation of the core of the repositories and data accesses with artificial transactions. 

Цель - создание двухуровневой системы репозиторий - слой доступа к данным (DAL) с возможностью безболезненного объединения методов DAL и слоя репозиториев транзакционно при отсутствии DTC, с возможностью безболезенной подмены слоя DAL. В реализиации возможная ошибка только при проведенни последнего commit искусственной транзакции, когда происходит физический коммит реальных транзакций. Если при этом возникнет ошибка в одной из транзакций, то другие все равно подтвердятся. Есть еще неприятный баг (признанный фичей), связанный со смещением транзакций слоя репозитория и слоя данных.

## Детали

В DP.Repository.UnitTest приведены примеры использования

```
// Создаем тестовый репозиторий SqlLite, работающий физически с двумя БД 1 и 2
var repository = Factory.GetRepositoryTest();

// Очищаем его, если что-то осталось с прошлых экспериментов
repository.Clear();

// Запускаем транзакцию уровня репозитория. При этом ни каких физических транзакций создано не будет
using ( var transaction = repository.Connection.BeginTransaction() )
{
    // Пишем в обе БД, при этом в момент записи будет создана физическая транзакция
    repository.InsertIds( 1, 2 );

    // Запускаем вложенную транзакцию
    using ( var transaction2 = repository.Connection.BeginTransaction() )
    {
        // Пишем в первую БД
        repository.InsertIdInDb1( -1 );
        
        // Закрываем вторую фиктивную транзакцию, физические при этом остаются открытми, так как есть еще открытая фиктивная
        transaction2.Commit();
    }

    // Закрываем первую фиктивную транзакцию, физические при этом последовательно закрываются. Вот тут и может произойти фича
    transaction.Commit();
}
```